% This program extracts atmospheric parameters from WRF output
% and sets surface and instrument parameters. Then it combines
% all parameters together and creates inputs arrays for DOTLRT run.
clear all;
close all;
clear classes;

disp('Now running codes for data preprocessing  !')

getpath
load([mainpath,datapath_sequence,'meteorology_data','.mat']);
get_simulation_plan
% Constants

%getdimstemp=ncread(wrfout,'P');
%epscbws = real(1);  % cosmic background permitivity
rowDim0 = size(GRAPEST,1);    % unstaggered longitude
colDim0 = size(GRAPEST,2);    % unstaggered latitude
zDim0 = size(GRAPEST,3);       % unstaggered altitude

ma = 28.96415; % mean molecular weight of air (Gram)
mv = 18.01528; % mean molecular weight of vapor (Gram)
R = 8.31451; % gas constant (J/mol-K)

inp_height = 350.0; % observation height (km AGL)
if user_angle_flag==1
     inp_theta = user_angle*ones(rowDim0,colDim0);
elseif exist([mainpath,sssdatapath,'GRAPES_angles.mat'],'file')
    load([mainpath,sssdatapath,'GRAPES_angles.mat']);inp_theta = GRAPES_angles; % nadir angle (degrees)
    inp_theta(isnan(inp_theta))=0;
else
    disp('Error')
end
num_streams = 8;  % total number of stream angles, including upward and downward propagating

num_levels = zDim0 + 1; % atm + surface level
atm_inp = zeros(rowDim0, colDim0, num_levels, 9);

% ==========load salinity=========
%-------------- It is believed that salinity is quite stable and can be
%considered as time independent
load([mainpath,sssdatapath,'SSS.mat'])
% salinity = salinity';
gcp();
for timeIndex=timeseries(1:size(timeseries,2))
    
    % reset dimension related parameters to unpolated scale
    rowDim=rowDim0;
    colDim=colDim0;
    zDim=zDim0;
    
    num_levels = zDim0 + 1;
    atm_inp = zeros(rowDim0, colDim0, num_levels, 9);
    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    timesuffix = timetab;% Will use this suffix to identify files
    disp(['Now preparing data for',timesuffix, '!'])
    
    % load ground parameters
    if surfemis_model==0
        load([mainpath,datapath,surfacefile,timesuffix,'.mat']);
        num_surf_angles = size(surface_inp,3); % number of angles for surface refelctivity
    elseif surfemis_model==1
        load([mainpath,datapath,surfacefile,timesuffix,'.mat']);
        num_surf_angles = surface_inp.num_surf_angles;
    end
    
    % read data (.txt) generated by ncl
    % wrf_user_getvar(wrfout, "z", time);  time = 1
    %
    % Variable: modelHeight
    % Type: float
    % Total Size: 9345836 bytes
    %             2336459 values
    % Number of Dimensions: 3
    % Dimensions and sizes:   [bottom_top | 59] x [south_north | 299] x [west_east | 239]
    % Coordinates:
    % Number Of Attributes: 6
    %   FieldType :   104
    %   MemoryOrder : XYZ
    %   description : Height
    %   units :       m
    %   stagger :
    %   coordinates : XLONG XLAT
%     modelHeight=load(['modelHeight',timesuffix,'.txt']);
%     modelHeight = reshape(modelHeight, rowDim, colDim, zDim);
    modelHeight = GRAPESheight;
    
    % Variable: temperature in K
%     modelTemperature=load(['modelTemperature',timesuffix,'.txt']);
%     temperature = reshape(modelTemperature, rowDim, colDim, zDim);
%     clear modelTemperature;
    temperature =GRAPEST;
    % Variable: pressure in mb
%     modelPressure=load(['modelPressure',timesuffix,'.txt']);
%     pressure = (reshape(modelPressure, rowDim, colDim, zDim));
%     clear modelPressure;
    pressure =GRAPESP;
    % Variable: relative humidity
%     modelRHumidity=load(['modelRHumidity',timesuffix,'.txt']);   %列向量被reshape成（按列排序）的矩阵
%     rh = reshape(modelRHumidity, rowDim, colDim, zDim);
%     clear modelRHumidity;
    rh =GRAPESRH;
    % read mixing ratio for vapor and other species
%     QVapor = double(ncread(wrfout, 'QVAPOR', [1,1,1,timeIndex], [Inf, Inf, Inf, 1]));
%     QCloud = double(ncread(wrfout, 'QCLOUD', [1,1,1,timeIndex], [Inf, Inf, Inf, 1]));
%     QRain = double(ncread(wrfout, 'QRAIN',  [1,1,1,timeIndex], [Inf, Inf, Inf, 1]));
    QVapor =GRAPESQv;
    QCloud =GRAPESQc;
    QRain =GRAPESQr;
    QIce =GRAPESQi;
    QSnow =GRAPESQs;
    QGraupel  =GRAPESQg;
    surfTemperature =GRAPESTSK;
%     try 
%         QIce = double(ncread(wrfout, 'QICE',  [1,1,1,timeIndex], [Inf, Inf, Inf, 1]));
%     catch
%         QIce = zeros(size(QVapor));
%     end
%     
%     try
%         QSnow = double(ncread(wrfout, 'QSNOW',  [1,1,1,timeIndex], [Inf, Inf, Inf, 1]));
%     catch
%         QSnow = zeros(size(QVapor));
%     end
%     
%     try
%         QGraupel = double(ncread(wrfout, 'QGRAUP',  [1,1,1,timeIndex], [Inf, Inf, Inf, 1]));
%     catch
%         QGraupel = zeros(size(QVapor));
%     end
%     
%     surfTemperature=double(ncread(wrfout,'TSK',  [1,1,timeIndex], [Inf, Inf,1]));
%     
    % allocate memory for OUTPUT arrays
    TbMap = zeros(rowDim, colDim, 2);
    dTb_dTCut = zeros(rowDim, colDim,zDim, 2);
    dTb_dpCut = zeros(rowDim, colDim,zDim, 2);
    dTb_dqCut = zeros(rowDim, colDim,zDim, 2);
    dTb_dClCut = zeros(rowDim,colDim, zDim, 2);
    dTb_dRnCut = zeros(rowDim,colDim, zDim, 2);
    dTb_dIceCut = zeros(rowDim,colDim, zDim, 2);
    dTb_dSnowCut = zeros(rowDim, colDim, zDim, 2);
    dTb_dGrpCut = zeros(rowDim, colDim,zDim, 2);
    surfRadTemp = zeros(rowDim, colDim, 2); % at smallest quadrature angle
    
    % calculate surface parameters and level-centric atmospheric parameters (e.g. vapor density and hydro density)
    
    Vdensity = zeros(rowDim, colDim, zDim);
    Cdensity = zeros(rowDim, colDim, zDim);
    Rdensity = zeros(rowDim, colDim, zDim);
    Idensity = zeros(rowDim, colDim, zDim);
    Sdensity = zeros(rowDim, colDim, zDim);
    Gdensity = zeros(rowDim, colDim, zDim);
    
    parfor rowIndex = 1:rowDim
        disp(['setup at row ' int2str(rowIndex)]);
        
        % Cross sectional cut at col: 75, 120, 150
        for colIndex = 1:colDim
            %disp(['column ' int2str(colIndex)]);
            
            % surface parameters
            %epssbws = permittivity(rowIndex, colIndex);
            Tsbws = surfTemperature(rowIndex, colIndex);
            
            %         specular surface reflectivity in v and h polarization
            %         [~,~,rfv,rfh] = frp3(gQuad.angle_01, epscbws, epssbws);
            %
            %         gQuad.angle_01 * 180.0 / pi
            %         rfv
            %         rfh
            %
            %         surface_inp(rowIndex, colIndex, :, 1) = fliplr(gQuad.angle_01 * 180.0 / pi);  % angles in degree in ascending order
            %         surface_inp(rowIndex, colIndex, :, 2) = fliplr(rfv);
            %         surface_inp(rowIndex, colIndex, :, 3) = fliplr(rfh);
            %
            %         surfRadTemp(rowIndex, colIndex, 1) = Tsbws * (1 - surface_inp(rowIndex, colIndex, 1, 3)); % H pol
            %         surfRadTemp(rowIndex, colIndex, 2) = Tsbws * (1 - surface_inp(rowIndex, colIndex, 1, 2)); % V pol
            
            % atmosphere parameters
            for zIndex = 1:zDim
                
                % water vapor density is calculated as function of temperature and relateive humidity
                % It also could be derived from mixing ratio
                % Dv = vaporMX*ma*level_pressure*100/(R*level_temp*(1+vaporMX*ma/mv));
                
                level_temp = temperature(rowIndex, colIndex, zIndex);   % layer temperature (K)
                rhumidity = rh(rowIndex, colIndex, zIndex) / 100.0;     % percentage between 0 and 1
                [vaporPres,vaporDensity] = vapor(level_temp, rhumidity, 0);
                
                vaporMX = QVapor(rowIndex, colIndex, zIndex);
                cloudMX = QCloud(rowIndex, colIndex, zIndex);
                rainMX = QRain(rowIndex, colIndex, zIndex);
                iceMX = QIce(rowIndex, colIndex, zIndex);
                snowMX = QSnow(rowIndex, colIndex, zIndex);
                graupelMX = QGraupel(rowIndex, colIndex, zIndex);
                
                Vdensity(rowIndex, colIndex, zIndex) = vaporDensity;
                Cdensity(rowIndex, colIndex, zIndex) = vaporDensity * cloudMX / vaporMX;
                Rdensity(rowIndex, colIndex, zIndex) = vaporDensity * rainMX / vaporMX;
                Idensity(rowIndex, colIndex, zIndex) = vaporDensity * iceMX / vaporMX;
                Sdensity(rowIndex, colIndex, zIndex) = vaporDensity * snowMX / vaporMX;
                Gdensity(rowIndex, colIndex, zIndex) = vaporDensity * graupelMX / vaporMX;
            end
        end
    end
    
    % calculate layer-centric atmospheric parameters by averaging values at top and bottom level
    
    disp(['layer-centric atmospheric parameters setting ... ']);
    for rowIndex = 1:rowDim
        rowDim
        for colIndex = 1:colDim
            
            Tsbws = surfTemperature(rowIndex, colIndex);
            
            % atmosphere parameters
            for zIndex = 1:zDim
                
                level_height = modelHeight(rowIndex, colIndex, zIndex) / 1000;   % level altitude (km AGL)
                
                if (zIndex == 1)
                    layer_pres = pressure(rowIndex, colIndex, zIndex);         % layer pressure (mb)
                    layer_temp = temperature(rowIndex, colIndex, zIndex);      % layer temperature (K)
                    layer_vden = Vdensity(rowIndex, colIndex, zIndex);         % layer water vapor density (g/m^3)
                    layer_cden = Cdensity(rowIndex, colIndex, zIndex);         % layer cloud liquid density (g/m^3)
                    layer_rden = Rdensity(rowIndex, colIndex, zIndex);         % layer rain density (g/m^3)
                    layer_iden = Idensity(rowIndex, colIndex, zIndex);         % layer ice density (g/m^3)
                    layer_sden = Sdensity(rowIndex, colIndex, zIndex);         % layer snow density (g/m^3)
                    layer_gden = Gdensity(rowIndex, colIndex, zIndex);         % layer graupel density (g/m^3)
                else
                    layer_pres = 0.5*(pressure(rowIndex, colIndex, zIndex) + pressure(rowIndex, colIndex, zIndex-1));
                    layer_temp = 0.5*(temperature(rowIndex, colIndex, zIndex) + temperature(rowIndex, colIndex, zIndex-1));
                    layer_vden = 0.5*(Vdensity(rowIndex, colIndex, zIndex) + Vdensity(rowIndex, colIndex, zIndex-1));
                    layer_cden = 0.5*(Cdensity(rowIndex, colIndex, zIndex) + Cdensity(rowIndex, colIndex, zIndex-1));
                    layer_rden = 0.5*(Rdensity(rowIndex, colIndex, zIndex) + Rdensity(rowIndex, colIndex, zIndex-1));
                    layer_iden = 0.5*(Idensity(rowIndex, colIndex, zIndex) + Idensity(rowIndex, colIndex, zIndex-1));
                    layer_sden = 0.5*(Sdensity(rowIndex, colIndex, zIndex) + Sdensity(rowIndex, colIndex, zIndex-1));
                    layer_gden = 0.5*(Gdensity(rowIndex, colIndex, zIndex) + Gdensity(rowIndex, colIndex, zIndex-1));
                end
                
                atm_inp(rowIndex, colIndex, zIndex+1, 1) = level_height;      % level altitude (km AGL)
                atm_inp(rowIndex, colIndex, zIndex+1, 2) = layer_pres;        % layer pressure (mb)
                atm_inp(rowIndex, colIndex, zIndex+1, 3) = layer_temp;        % layer temperature (K)
                atm_inp(rowIndex, colIndex, zIndex+1, 4) = layer_vden;        % layer water vapor density (g/m^3)
                atm_inp(rowIndex, colIndex, zIndex+1, 5) = layer_cden;        % layer cloud liquid density (g/m^3)
                atm_inp(rowIndex, colIndex, zIndex+1, 6) = layer_rden;        % layer rain density (g/m^3)
                atm_inp(rowIndex, colIndex, zIndex+1, 7) = layer_iden;        % layer ice density (g/m^3)
                atm_inp(rowIndex, colIndex, zIndex+1, 8) = layer_sden;        % layer snow density (g/m^3)
                atm_inp(rowIndex, colIndex, zIndex+1, 9) = layer_gden;        % layer graupel density (g/m^3)
            end
            
            % level 1: at surface, set surface temperature; set other parameters to be the same as level 2 at ~30 meters altitude
            atm_inp(rowIndex, colIndex, 1, 1) = 0;
            atm_inp(rowIndex, colIndex, 1, 2) = atm_inp(rowIndex, colIndex, 2, 2);  % surface pressure, not used
            atm_inp(rowIndex, colIndex, 1, 3) = Tsbws;
            atm_inp(rowIndex, colIndex, 1, 4) = atm_inp(rowIndex, colIndex, 2, 4);  % surface vapor density, not used
            
        end
    end
    
    validation_matrix=ones(rowDim,colDim);
    % save everything needed to run DOTLRT to everything.mat
    save([mainpath,datapath,'everything',timesuffix,'.mat'], 'rowDim', 'colDim', 'surface_inp', 'num_surf_angles', ...
        'atm_inp','num_levels', 'inp_height', 'inp_theta', 'num_streams'...,
        ,'num_surf_angles', 'num_levels'...
        ,'dTb_dTCut', 'dTb_dpCut', 'dTb_dqCut', 'dTb_dClCut', 'dTb_dRnCut', 'dTb_dIceCut'...
        ,'dTb_dSnowCut', 'dTb_dGrpCut','zDim','validation_matrix','salinity');
    
    %%%+++++++++++++ Interp to ATMS and save again +++++++++++++++++++
    if interplot_to_ATMS_coords_at_differentangles == 1
        interplotting_wrf_to_ATMS
        
        save([mainpath,datapath,'interp/','everything',timesuffix,'.mat'], 'rowDim', 'colDim', 'surface_inp', 'num_surf_angles', ...
            'atm_inp','num_levels', 'inp_height', 'inp_theta', 'num_streams'...,
            ,'num_surf_angles', 'num_levels'...
            ,'dTb_dTCut', 'dTb_dpCut', 'dTb_dqCut', 'dTb_dClCut', 'dTb_dRnCut', 'dTb_dIceCut'...
            ,'dTb_dSnowCut', 'dTb_dGrpCut','zDim','validation_matrix','salinity');
    end
    %%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    
    
    
end
delete(gcp);
% matlabpool close
% Then Run DOTLRT on everything.mat


